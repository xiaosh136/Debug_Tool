

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                                                                                        ;;
;;                                Copyright (c) 2019-2020 by Pizer.Fan                                    ;;
;;                                                                                                        ;;
;;  This software is copyrighted by and is the sole property of Pizer.Fan. All rights, title, ownership,  ;;
;;  or other interests in the software remain the property of Pizer.Fan. Any unauthorized use,            ;;
;;  duplication, transmission, distribution, or disclosure of this software is expressly forbidden.       ;;
;;  This Copyright notice may not be removed or modified without prior written consent of Pizer.Fan       ;;
;;                                                                                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  TM Component                                                                                          ;;
;;                                                                                                        ;;
;;    Task Monitor : Export the data to the host file                                                     ;;
;;                                                                                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Release History                                                                                       ;;
;;                                                                                                        ;;
;;    Date              Name                      Description                                             ;;
;;                                                                                                        ;;
;;  2020/08/07      Pizer.Fan                   Initial Version                                           ;;
;;                                                                                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; Create logging output window
area.create logging_win 200. 500.
area.select logging_win
area.view logging_win

;PMACRO.list
local &err
&err=0

&last_ts = 0

; Enter the export directory if null
global &_global_export_dir
&curr_script_dir=os.ppd()
do "&curr_script_dir\_setting_input_export_dir_if_null.cmm"
&export_dir="&_global_export_dir"
if "&(export_dir)"==""
(
  &export_dir=os.pwd()
)

print "Export to directory : &(export_dir)"
print "Start time : " clock.date() "  " clock.time() "  ..."
print ""


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Start ...                                                                                             ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

if !(symbol.exist(tm_info))
(
  &err=1
  print "Error: `tm_info' does not exist. EXIT script"
  goto CMM_END
)

; Get TM version
&name=v.value(tm_info.head.magic)
&name=data.string(d:&name)
&len=string.length("&name")
&name=string.mid("&name", 0, v.value(&len-1))
print "Task Monitor Version: &name"

if ("&name"=="TASKMONITORV2.20")
(
  print "  Cpu Number        : " format.decimal(0, v.value(tm_info.head.cpu_num))
  print "  Blocks Counter    : " format.decimal(0, v.value(tm_info.head.blocks_cnt))
  print "  Block Data Size   : " format.decimal(0, v.value(tm_info.head.block_data_size))
  
  global &_global_tm_block_data
  global &_global_tm_block_data_len
  global &_global_tm_block_data_point_cnt
  
  &core_index=0
  &core_num=v.value(tm_info.head.cpu_num)
  while (v.value(&core_index)<v.value(&core_num))
  (
    ; Makeup output file path
    local &output_file_path
    local &output_file_name
    local &core_name
    if symbol.exist(LOG_magicHeader)
    (
      &core_name=data.string(d:v.value(LOG_magicHeader.coreName))
      &output_file_name="tm_data_&(core_name)"
    )
    else
    (
      &output_file_name="tm_data"
    )
    &core_index_decimal=format.decimal(0,v.value(&core_index))
    &output_file_path="&(export_dir)/&(output_file_name)_cpu&core_index_decimal.txt"

    ; Create output file
    area.create output_file_win 200. 500.
    area.open output_file_win "&output_file_path"
    area.select output_file_win

    &block_num=v.value(tm_info.head.blocks_cnt)
    
    ; get max & min seq num
    area.select logging_win
    print ""
    print "Scan the max & min seq num of CPU[&core_index]"
    area.select output_file_win
    &block_index=0
    &block_max_seq_num=0
    &block_max_seq_num_index=0
    &block_min_seq_num=0xFFFFFFFF
    &block_min_seq_num_index=0
    while (v.value(&block_index)<v.value(&block_num))
    (
      &block=v.value(&tm_info.blocks[&core_index][&block_index])
      &block_seq_num=v.value(((TM_FRAME_BUFFER_T *)&block)->seq_num)
      &block_total_len=v.value(((TM_FRAME_BUFFER_T *)&block)->len)
      &block_data_len=v.value(&block_total_len-8)
      &block_data=v.value(((TM_FRAME_BUFFER_T *)&block)->data)
      if (&block_data_len>0)
      (
        if (v.value(&block_seq_num)>=v.value(&block_max_seq_num))
        (
          &block_max_seq_num=&block_seq_num
          &block_max_seq_num_index=&block_index
        )
        if (v.value(&block_seq_num)<v.value(&block_min_seq_num))
        (
          &block_min_seq_num=&block_seq_num
          &block_min_seq_num_index=&block_index
        )
      )
      area.select logging_win
      print "[&core_index][&block_index] : &block, &block_data_len, " v.value(&block_seq_num)
      area.select output_file_win
      &block_index=&block_index+1
    )
    
    area.select logging_win
    print "min: [&core_index][&block_min_seq_num_index] : &block_min_seq_num"
    print "max: [&core_index][&block_max_seq_num_index] : &block_max_seq_num"
    area.select output_file_win
    
    if (v.value(&block_min_seq_num_index)>v.value(&block_max_seq_num_index))
    (
      ; export from min to end
      area.select logging_win
      print "export from min to end: [&block_min_seq_num_index, &block_num)"
      area.select output_file_win
      &block_index=&block_min_seq_num_index
      while (v.value(&block_index)<v.value(&block_num))
      (
        &block=v.value(&tm_info.blocks[&core_index][&block_index])
        &block_seq_num=v.value(((TM_FRAME_BUFFER_T *)&block)->seq_num)
        &block_total_len=v.value(((TM_FRAME_BUFFER_T *)&block)->len)
        &block_data_len=v.value(&block_total_len-8)
        &block_data=v.value(((TM_FRAME_BUFFER_T *)&block)->data)
        if (v.value(&block_data_len)>v.value("0"))
        (
          do "&curr_script_dir\_tm_export_v220_block_data.cmm" "&block_data" "&block_data_len"
          area.select logging_win
          print "[&core_index][&block_index] : &block, &block_data_len, " v.value(&_global_tm_block_data_point_cnt)
          area.select output_file_win
        )
        &block_index=&block_index+1
      )
      
      ; export from end to max
      area.select logging_win
      print "export from end to max: [0, &block_max_seq_num_index]"
      area.select output_file_win
      &block_index=0
      while (v.value(&block_index)<=v.value(&block_max_seq_num_index))
      (
        &block=v.value(&tm_info.blocks[&core_index][&block_index])
        &block_seq_num=v.value(((TM_FRAME_BUFFER_T *)&block)->seq_num)
        &block_total_len=v.value(((TM_FRAME_BUFFER_T *)&block)->len)
        &block_data_len=v.value(&block_total_len-8)
        &block_data=v.value(((TM_FRAME_BUFFER_T *)&block)->data)
        if (v.value(&block_data_len)>v.value("0"))
        (
          do "&curr_script_dir\_tm_export_v220_block_data.cmm" "&block_data" "&block_data_len"
          area.select logging_win
          print "[&core_index][&block_index] : &block, &block_data_len, " v.value(&_global_tm_block_data_point_cnt)
          area.select output_file_win
        )
        &block_index=&block_index+1
      )
    )
    else
    (
      ; export from min to max
      area.select logging_win
      print "export from min to max: [&block_min_seq_num_index, &block_max_seq_num_index]"
      area.select output_file_win
      &block_index=&block_min_seq_num_index
      while (v.value(&block_index)<=v.value(&block_max_seq_num_index))
      (
        &block=v.value(&tm_info.blocks[&core_index][&block_index])
        &block_seq_num=v.value(((TM_FRAME_BUFFER_T *)&block)->seq_num)
        &block_total_len=v.value(((TM_FRAME_BUFFER_T *)&block)->len)
        &block_data_len=v.value(&block_total_len-8)
        &block_data=v.value(((TM_FRAME_BUFFER_T *)&block)->data)
        if (v.value(&block_data_len)>v.value("0"))
        (
          do "&curr_script_dir\_tm_export_v220_block_data.cmm" "&block_data" "&block_data_len"
          area.select logging_win
          print "[&core_index][&block_index] : &block, &block_data_len, " v.value(&_global_tm_block_data_point_cnt)
          area.select output_file_win
        )
        &block_index=&block_index+1
      )
    )
    
    ; export max if (data length is 0)
    area.select logging_win
    print "export max if (data length is 0): &block_max_seq_num_index"
    area.select output_file_win
    &block_index=&block_max_seq_num_index
    &block=v.value(&tm_info.blocks[&core_index][&block_index])
    &block_seq_num=v.value(((TM_FRAME_BUFFER_T *)&block)->seq_num)
    &block_total_len=v.value(((TM_FRAME_BUFFER_T *)&block)->len)
    &block_data_len=v.value(&block_total_len-8)
    if (&block_data_len!=0)
    (
      &block_index=&block_max_seq_num_index+1
      if (&block_index==&block_num)
      (
        &block_index=0
      )
      &block=v.value(&tm_info.blocks[&core_index][&block_index])
      &block_seq_num=v.value(((TM_FRAME_BUFFER_T *)&block)->seq_num)
      &block_total_len=v.value(((TM_FRAME_BUFFER_T *)&block)->len)
      &block_data_len=v.value(&block_total_len-8)
    )
    &block_data=v.value(((TM_FRAME_BUFFER_T *)&block)->data)
    if (v.value(&block_data_len)==v.value("0")&&v.value(tm_curr_data_index[&core_index])!=v.value("0"))
    (
      ; print "==========================================="
      &block_data_len=v.value(tm_curr_data_index[&core_index]*4)
      do "&curr_script_dir\_tm_export_v220_block_data.cmm" "&block_data" "&block_data_len"
      area.select logging_win
      print "[&core_index][&block_index] : &block, &block_data_len, " v.value(&_global_tm_block_data_point_cnt)
      area.select output_file_win
    )
    
    ; open the output file.
    print ""
    area.close output_file_win
    area.clear output_file_win
	&output_file_path2="&(export_dir)/&(output_file_name)_cpu&(core_index_decimal)_task_runtime.txt"
	do "&curr_script_dir\_tm_analyze_run_time.cmm" "&output_file_path" "&output_file_path2"
	type "&output_file_path"
	type "&output_file_path2"
    ; next core
    &core_index=&core_index+1
  )
)
else if ("&name"=="TASKMONITORV2.00")
(
  print "  Cpu Number        : 1"
  print "  Max Points        : " format.decimal(0, v.value(tm_info.head.nrof_point))
  
  &core_index=0
  &core_num=1
  &max_points=v.value(tm_info.head.nrof_point)
  while (v.value(&core_index)<v.value(&core_num))
  (
    ; Makeup output file path
    local &output_file_path
    local &output_file_name
    &output_file_name="tm_data"
    &core_index_decimal=format.decimal(0,v.value(&core_index))
    &output_file_path="&(export_dir)/&(output_file_name)_cpu&core_index_decimal.txt"

    ; Create output file
    area.create output_file_win 200. 500.
    area.open output_file_win "&output_file_path"
    area.select output_file_win

    ; get the start
    area.select logging_win
    print ""
    print "Scan the start point of CPU[&core_index]"
    area.select output_file_win
    &point_max_time=0
    &point_index=0
    &start_point_index=0
    &end_point_index=&max_points-1
    while (v.value(&point_index)<v.value(&max_points))
    (
      if (v.value(&point_max_time)<=v.value(tm_info.point_tab[&point_index].time))
      (
        &point_max_time=v.value(tm_info.point_tab[&point_index].time)
        &point_index=&point_index+1
      )
      else
      (
        &start_point_index=&point_index
        &end_point_index=&point_index-1
        goto CMM_V200_SEARCH_START_POINT_END
      )
    )
    
CMM_V200_SEARCH_START_POINT_END:
    area.select logging_win
    print "  begin at [" format.decimal(0, v.value(&start_point_index)) "].time=" format.decimal(0, v.value(tm_info.point_tab[&start_point_index].time))
    print "  end at [" format.decimal(0, v.value(&end_point_index)) "].time=" format.decimal(0, v.value(tm_info.point_tab[&end_point_index].time))
    area.select output_file_win
    
    if (v.value(&start_point_index)>v.value(&end_point_index))
    (
      ; export from start to end
      &point_index=&start_point_index
      while (v.value(&point_index)<v.value(&max_points))
      (
        do "&curr_script_dir\_tm_export_v200_data.cmm" "&point_index" "&last_ts" "&last_ts"
        &point_index=&point_index+1
      )
      
      ; export from end to max
      &point_index=0
      while (v.value(&point_index)<=v.value(&end_point_index))
      (
        do "&curr_script_dir\_tm_export_v200_data.cmm" "&point_index" "&last_ts" "&last_ts"
        &point_index=&point_index+1
      )
    )
    else
    (
      &point_index=&start_point_index
      while (v.value(&point_index)<=v.value(&end_point_index))
      (
        do "&curr_script_dir\_tm_export_v200_data.cmm" "&point_index" "&last_ts" "&last_ts"
        &point_index=&point_index+1
      )
    )
    
    ; open the output file.
    print ""
    area.close output_file_win
    area.clear output_file_win
	&output_file_path2="&(export_dir)/&(output_file_name)_cpu&(core_index_decimal)_task_runtime.txt"
	do "&curr_script_dir\_tm_analyze_run_time.cmm" "&output_file_path" "&output_file_path2"
	type "&output_file_path"
	type "&output_file_path2"
    ; next core
    &core_index=&core_index+1
  )
)
else if ("&name"=="TASKMONITORBEGIN")
(
  print "  Cpu Number        : 1"
  print "  Max Points        : " format.decimal(0, v.value(tm_info.head.nrof_point))
  
  &core_index=0
  &core_num=1
  &max_points=v.value(tm_info.head.nrof_point)
  while (v.value(&core_index)<v.value(&core_num))
  (
    ; Makeup output file path
    local &output_file_path
    local &output_file_name
    &output_file_name="tm_data"
    &core_index_decimal=format.decimal(0,v.value(&core_index))
    &output_file_path="&(export_dir)/&(output_file_name)_cpu&core_index_decimal.txt"

    ; Create output file
    area.create output_file_win 200. 500.
    area.open output_file_win "&output_file_path"
    area.select output_file_win

    ; get the start
    area.select logging_win
    print ""
    print "Scan the start point of CPU[&core_index]"
    area.select output_file_win
    &point_max_time=0
    &point_index=0
    &start_point_index=0
    &end_point_index=&max_points-1
    while (v.value(&point_index)<v.value(&max_points))
    (
      if (v.value(&point_max_time)<=v.value(tm_info.point_tab[&point_index].time))
      (
        &point_max_time=v.value(tm_info.point_tab[&point_index].time)
        &point_index=&point_index+1
      )
      else
      (
        &start_point_index=&point_index
        &end_point_index=&point_index-1
        goto CMM_V199_SEARCH_START_POINT_END
      )
    )
    
CMM_V199_SEARCH_START_POINT_END:
    area.select logging_win
    print "  begin at [" format.decimal(0, v.value(&start_point_index)) "].time=" format.decimal(0, v.value(tm_info.point_tab[&start_point_index].time))
    print "  end at [" format.decimal(0, v.value(&end_point_index)) "].time=" format.decimal(0, v.value(tm_info.point_tab[&end_point_index].time))
    area.select output_file_win
    
    if (v.value(&start_point_index)>v.value(&end_point_index))
    (
      ; export from start to end
      &point_index=&start_point_index
      while (v.value(&point_index)<v.value(&max_points))
      (
        do "&curr_script_dir\_tm_export_v199_data.cmm" "&point_index" "&last_ts" "&last_ts"
        &point_index=&point_index+1
      )
      
      ; export from end to max
      &point_index=0
      while (v.value(&point_index)<=v.value(&end_point_index))
      (
        do "&curr_script_dir\_tm_export_v199_data.cmm" "&point_index" "&last_ts" "&last_ts"
        &point_index=&point_index+1
      )
    )
    else
    (
      &point_index=&start_point_index
      while (v.value(&point_index)<=v.value(&end_point_index))
      (
        do "&curr_script_dir\_tm_export_v199_data.cmm" "&point_index" "&last_ts" "&last_ts"
        &point_index=&point_index+1
      )
    )
    
    ; open the output file.
    print ""
    area.close output_file_win
    area.clear output_file_win
	&output_file_path2="&(export_dir)/&(output_file_name)_cpu&(core_index_decimal)_task_runtime.txt"
	do "&curr_script_dir\_tm_analyze_run_time.cmm" "&output_file_path" "&output_file_path2"
	type "&output_file_path"
	type "&output_file_path2"
    ; next core
    &core_index=&core_index+1
  )
)
else
(
  &err=1
  print "This version is not supported now!"
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  End                                                                                                   ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CMM_END:
area.select logging_win

print ""
print "End time : " clock.date() "  " clock.time() "  "

; Close the logging output window
; wait 1s
if (&err==0)
(
  area.close logging_win
  do "&curr_script_dir\_trace32_area_delete.cmm" "logging_win"
)

enddo
