

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                                                                                        ;;
;;                                Copyright (c) 2019-2020 by Pizer.Fan                                    ;;
;;                                                                                                        ;;
;;  This software is copyrighted by and is the sole property of Pizer.Fan. All rights, title, ownership,  ;;
;;  or other interests in the software remain the property of Pizer.Fan. Any unauthorized use,            ;;
;;  duplication, transmission, distribution, or disclosure of this software is expressly forbidden.       ;;
;;  This Copyright notice may not be removed or modified without prior written consent of Pizer.Fan       ;;
;;                                                                                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  LOG Component                                                                                         ;;
;;                                                                                                        ;;
;;    LOG :                                                                                               ;;
;;                                                                                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Release History                                                                                       ;;
;;                                                                                                        ;;
;;    Date              Name                      Description                                             ;;
;;                                                                                                        ;;
;;  2020/08/07      Pizer.Fan                   Initial Version                                           ;;
;;                                                                                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; Create logging output window
area.create logging_win 200. 500.
area.select logging_win
area.view logging_win

;PMACRO.list
local &err
&err=0

; Enter the export directory if null
global &_global_export_dir
&curr_script_dir=os.ppd()
do "&curr_script_dir\_setting_input_export_dir_if_null.cmm"
&export_dir="&_global_export_dir"
if "&(export_dir)"==""
(
  &export_dir=os.pwd()
)

; Makeup output file path
local &output_file_path
local &output_file_name
local &core_name
if symbol.exist(LOG_magicHeader)
(
  &core_name=data.string(d:v.value(LOG_magicHeader.coreName))
  &output_file_name="log_chan_buf_list_&(core_name).txt"
)
else
(
  &output_file_name="log_chan_buf_list.txt"
)
&output_file_path="&(export_dir)/&output_file_name"

print "Export to directory : &(export_dir)"
print "Start time : " clock.date() "  " clock.time() "  ..."
print ""


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Start ...                                                                                             ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

local &head_symbol
&head_symbol="g_sblock_mgr"
if !(symbol.exist(&head_symbol))
(
  &err=1
  print "Error: `g_sblock_mgr' does not exist. EXIT script"
  goto CMM_END
)

; Create output file
area.create output_file_win 200. 500.
area.open output_file_win "&output_file_path"
area.select output_file_win


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  g_sblock_mgr info                                                                                     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

&chanbuff_pool=v.value("&g_sblock_mgr[0].sblock_cb_mgr")
&chanbuff_pool_buffer=v.value("g_sblock_mgr[0].sblock_cb_mgr.buffer")
&chanbuff_pool_blk_space=v.value("g_sblock_mgr[0].sblock_cb_mgr.blk_space")
&chanbuff_pool_blk_size=v.value("g_sblock_mgr[0].sblock_cb_mgr.blk_size")
&chanbuff_pool_blk_cnt=v.value("g_sblock_mgr[0].sblock_cb_mgr.blk_cnt")
&chanbuff_pool_free_cnt=v.value("g_sblock_mgr[0].sblock_cb_mgr.free_cnt")
&chanbuff_pool_free_head=v.value("g_sblock_mgr[0].sblock_cb_mgr.free_head")

&chanbuff_item_mem_hdr_size=&chanbuff_pool_blk_space-&chanbuff_pool_blk_size

&chanbuff_pool_blk_cnt_fmt=format.decimal(0,v.value(&chanbuff_pool_blk_cnt))
&chanbuff_pool_free_cnt_fmt=format.decimal(0,v.value(&chanbuff_pool_free_cnt))

print ""
print "===============Summary info==============="
print  " struct SciBlockPool sblock_cb_mgr=&chanbuff_pool {"
print  "   buffer=&chanbuff_pool_buffer"
print  "   blk_cnt=&chanbuff_pool_blk_cnt_fmt"
print  "   free_cnt=&chanbuff_pool_free_cnt_fmt"
print  "   free_head=&chanbuff_pool_free_head"
print  " }"


local &item
local &i
&i=0
&item=&chanbuff_pool_buffer

print ""
print "===============List buffer info==============="
if (&chanbuff_pool_blk_space==v.value("60"))
(
  print "   [addr]   [link]   chan-buf base-mgr buf        len   offset   payload_len   shm_addr shm_length alloc_line  free_line"
)
else
(
  print "   [addr]   [link]   chan-buf base-mgr buf        len   offset   payload_len   shm_addr shm_length"
)

local &next_link
local &mgr
local &buf
local &len
local &data_offset
local &payload_len
local &shm_addr
local &shm_length
local &alloc_file_addr
local &alloc_file
local &alloc_line_val
local &alloc_line
local &free_file_addr
local &free_file
local &free_line_val
local &free_line

CMM_LOOP_1:

&item_addr=format.hex(8,v.value("&item"))
&next_link=format.hex(8,v.value("(*((unsigned int*)&item))"))
&chan_buf=format.hex(8,v.value("(struct SblockChannelBuffer*)(&item+&chanbuff_item_mem_hdr_size)"))
&mgr=format.hex(8,v.value("((*(((struct SblockChannelBuffer*)(&item+&chanbuff_item_mem_hdr_size)))).base).mgr"))
&buf=format.hex(8,v.value("((*(((struct SblockChannelBuffer*)(&item+&chanbuff_item_mem_hdr_size)))).base).buf"))
&len=format.decimal(6,v.value("((*(((struct SblockChannelBuffer*)(&item+&chanbuff_item_mem_hdr_size)))).base).len"))
&data_offset=format.decimal(6,v.value("((*(((struct SblockChannelBuffer*)(&item+&chanbuff_item_mem_hdr_size)))).base).data_offset"))
&payload_len=format.decimal(8,v.value("((*(((struct SblockChannelBuffer*)(&item+&chanbuff_item_mem_hdr_size)))).base).payload_len"))
&shm_addr=format.hex(8,v.value("((*(((struct SblockChannelBuffer*)(&item+&chanbuff_item_mem_hdr_size)))).sblock).addr"))
&shm_length=format.decimal(8,v.value("((*(((struct SblockChannelBuffer*)(&item+&chanbuff_item_mem_hdr_size)))).sblock).length"))
if (&chanbuff_pool_blk_space==v.value("60"))
(
	&alloc_file_addr=v.value("(*(((struct SciBlockHeader*)(&item)))).alloc_file")
	&alloc_file=data.string(d:v.value(&alloc_file_addr))
	&alloc_line_val=v.value("(*(((struct SciBlockHeader*)(&item)))).alloc_line")
	&alloc_line=format.decimal(8,&alloc_line_val)
	&free_file_addr=v.value("(*(((struct SciBlockHeader*)(&item)))).free_file")
	&free_file=data.string(d:v.value(&free_file_addr))
	&free_line_val=v.value("(*(((struct SciBlockHeader*)(&item)))).free_line")
	&free_line=format.decimal(8,&free_line_val)
)
if (&chanbuff_pool_blk_space==v.value("60"))
(
	LOCAL &useFlag;
	&useFlag=" "
	if ((&alloc_line_val!=v.value("0"))&&(&free_line_val==v.value("0")))
	(
		&useFlag="T"
	)
	if (&chanbuff_pool_free_head==&item)
	(
		print  "*&useFlag &item_addr &next_link &chan_buf &mgr &buf &len &data_offset &payload_len         &shm_addr &shm_length &alloc_line &free_line"
	)
	else
	(
		print  " &useFlag &item_addr &next_link &chan_buf &mgr &buf &len &data_offset &payload_len         &shm_addr &shm_length &alloc_line &free_line"
	)
)
else
(
	if (&chanbuff_pool_free_head==&item)
	(
		print  "*  &item_addr &next_link &chan_buf &mgr &buf &len &data_offset &payload_len         &shm_addr &shm_length"
	)
	else
	(
		print  "   &item_addr &next_link &chan_buf &mgr &buf &len &data_offset &payload_len         &shm_addr &shm_length"
	)
)

&item=&item+&chanbuff_item_mem_hdr_size
&item=&item+v.value("sizeof(struct SblockChannelBuffer)")
&i=&i+1

if (&i!=&chanbuff_pool_blk_cnt)
	goto CMM_LOOP_1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  End                                                                                                   ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CMM_FILE_CLOSE:
print ""
area.close output_file_win
area.clear output_file_win

type "&output_file_path"

CMM_END:
area.select logging_win

print ""
print "End time : " clock.date() "  " clock.time() "  "

; Close the logging output window
; wait 1s
if (&err==0)
(
  area.close logging_win
  do "&curr_script_dir\_trace32_area_delete.cmm" "logging_win"
)

enddo
