

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                                                                                        ;;
;;                                Copyright (c) 2019-2020 by Pizer.Fan                                    ;;
;;                                                                                                        ;;
;;  This software is copyrighted by and is the sole property of Pizer.Fan. All rights, title, ownership,  ;;
;;  or other interests in the software remain the property of Pizer.Fan. Any unauthorized use,            ;;
;;  duplication, transmission, distribution, or disclosure of this software is expressly forbidden.       ;;
;;  This Copyright notice may not be removed or modified without prior written consent of Pizer.Fan       ;;
;;                                                                                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  OSA/TX Component                                                                                      ;;
;;                                                                                                        ;;
;;    Memory: Export the allocations of a byte pool into the HOST file                                   ;;
;;                                                                                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Release History                                                                                       ;;
;;                                                                                                        ;;
;;    Date              Name                      Description                                             ;;
;;                                                                                                        ;;
;;  2020/08/07      Pizer.Fan                   Initial Version                                           ;;
;;                                                                                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; Create logging output window
area.create logging_win 200. 500.
area.select logging_win
area.view logging_win

;PMACRO.list
local &err
&err=0

; Enter the export directory if null
global &_global_export_dir
&curr_script_dir=os.ppd()
do "&curr_script_dir\_setting_input_export_dir_if_null.cmm"
&export_dir="&_global_export_dir"
if "&(export_dir)"==""
(
  &export_dir=os.pwd()
)

; const values
global &ENTITY_INFRA &ENTITY_STACK &ENTITY_GSM_STACK &ENTITY_W_STACK &ENTITY_SIGNAL
global &ENTITY_TD_LTE_STACK &ENTITY_IMS_STACK &ENTITY_NR_STACK
global &ENTITY_PSEUDO_START &ENTITY_OSA &ENTITY_USER &ENTITY_LAST &ENTITY_KAL
do "&curr_script_dir\_osa_load_entity_values.cmm"
&entity_cnt=v.value(sizeof(entity_name)/sizeof(entity_name[0]))

print "Please input the address of byte pool: "
enter &input_ptr

if ("&input_ptr"=="")
(
  &err=1
  print "Error: No input !!!. EXIT script"
  goto CMM_END
)

if (string.scan("&input_ptr","0x",0)==-1)&&(string.scan("&input_ptr","0X",0)==-1)
(
  &input_ptr_string="0x&input_ptr"
  &input_ptr=v.value(&input_ptr_string)
)

&byte_static_heap_addr=v.value("&byte_static_heap")
&byte_dynamic_base_heap_addr=v.value("&byte_dynamic_base_heap")
&byte_dynamic_app_heap_addr=v.value("&byte_dynamic_app_heap")

&ppool_ctl_block=&input_ptr
&tx_byte_pool_id=data.string(d:v.value(((osa_os_mem_pool_type *)&ppool_ctl_block)->tx_byte_pool_id))
&tx_byte_pool_name_addr=v.value(((osa_os_mem_pool_type *)&ppool_ctl_block)->tx_byte_pool_name)
&tx_byte_pool_name=data.string(d:v.value(((osa_os_mem_pool_type *)&ppool_ctl_block)->tx_byte_pool_name))
&tx_byte_pool_size=v.value(((osa_os_mem_pool_type*)&ppool_ctl_block)->tx_byte_pool_size)
&tx_byte_pool_available=v.value(((osa_os_mem_pool_type*)&ppool_ctl_block)->tx_byte_pool_available)
&tx_byte_pool_start=v.value(((osa_os_mem_pool_type*)&ppool_ctl_block)->tx_byte_pool_start)
&tx_byte_pool_end=v.value(&tx_byte_pool_start+&tx_byte_pool_size)

; Makeup output file path
local &output_file_path
local &output_file_name
&output_file_name="osa_tx_byte_pool_allocs_&(ppool_ctl_block)_&(tx_byte_pool_name).txt"
&output_file_path="&(export_dir)/&output_file_name"

print "Export to directory : &(export_dir)"
print "Start time : " clock.date() "  " clock.time() "  ..."
print ""

; Create output file
area.create output_file_win 200. 500.
area.open output_file_win "&output_file_path"
area.select output_file_win

print ""
print "===============Allocated memory info(in byte pool: &tx_byte_pool_name, &ppool_ctl_block)==============="
print "     Addr     Next       Index.    Size  Entity_ID  FileName  (Line)    User-Addr"

&next_link_ptr=&tx_byte_pool_start
&curr_link_ptr=&next_link_ptr

CMM_LOOP_BYTE_POOL:

&curr_link_ptr=&next_link_ptr
&curr_link_end_ptr=&next_link_ptr
&next_link_ptr_value=v.value(*(unsigned int*)&next_link_ptr)
&free_ptr=(&next_link_ptr+4)
&free_ptr_value=v.value(*(unsigned int*)&free_ptr)
&ptr=(&next_link_ptr+8)

; sdi_mem_int_free
&hdr_index=v.value(((osa_mem_hdr_struct*)&ptr)->index)
&free_func=v.value(*(unsigned int *)&((osa_mem_hdr_struct*)&ptr)->usr_buff[0])
&user_ptr=(&ptr+8)

&MEM_INVALID_STATE=v.value(0)
&OSA_MEM_DEALLOCATED=v.value(1)
&OSA_MEM_ALLOCATED=v.value(2)

; var.print *((osa_mem_hdr_struct*)&ptr)

if (v.value(&free_ptr_value)==v.value(&input_ptr))
(
  if ((v.value(&input_ptr)==v.value(&byte_static_heap_addr))||(v.value(&input_ptr)==v.value(&byte_dynamic_base_heap_addr))||(v.value(&input_ptr)==v.value(&byte_dynamic_app_heap_addr)))
  (
    &hdr_index=v.value(((byte_heap_hdr_struct*)&ptr)->block_num)
    &hdr_index_fmt=format.decimal(8,&hdr_index)
    &dbg_size=v.value(((byte_heap_hdr_struct*)&ptr)->size)
    &dbg_size_fmt=format.decimal(8,&dbg_size)
    &dbg_file_ent_id=&ENTITY_LAST
    &dbg_file_ent_id_fmt=format.decimal(8,&dbg_file_ent_id)
    &dbg_file_code_fmt=data.string(d:v.value(((byte_heap_hdr_struct*)&ptr)->file_name))
    &dbg_line_no=v.value(((byte_heap_hdr_struct*)&ptr)->line)
    &dbg_line_no_fmt=format.decimal(8,&dbg_line_no)

    print  "&curr_link_ptr &next_link_ptr_value &(hdr_index_fmt) &(dbg_size_fmt)      -      &(dbg_file_code_fmt) &(dbg_line_no_fmt)    &(user_ptr)"
  )
  else
  (
    &dbg_mem_state=v.value(osa_mem_log_g[&hdr_index].mem_state)
    &dbg_size=v.value(osa_mem_log_g[&hdr_index].size)
    &dbg_file_ent_id=v.value(osa_mem_log_g[&hdr_index].trans_src.file_ent_id)
    &dbg_file_code=v.value(osa_mem_log_g[&hdr_index].trans_src.file_code)
    &dbg_line_no=v.value(osa_mem_log_g[&hdr_index].trans_src.line_no)
    &dbg_ptr=v.value(osa_mem_log_g[&hdr_index].ptr)
    &dbg_task_id=v.value((osa_internal_taskid)osa_mem_log_g[&hdr_index].task_id)
    &dbg_thread_name=""
    if (v.value(&dbg_task_id)!=v.value(0))
    (
      &dbg_thread_name_addr=v.value((*(((osa_internal_taskid)&dbg_task_id))).task_id.thread.tx_thread_name)
      &dbg_thread_name=data.string(d:&dbg_thread_name_addr)
    )

    &hdr_index_fmt=format.decimal(8,&hdr_index)
    &dbg_size_fmt=format.decimal(8,&dbg_size)
    &dbg_file_ent_id_fmt=format.decimal(8,&dbg_file_ent_id)
    &dbg_file_code_fmt=format.decimal(8,&dbg_file_code)
    &dbg_line_no_fmt=format.decimal(8,&dbg_line_no)
  
    print  "&curr_link_ptr &next_link_ptr_value &(hdr_index_fmt) &(dbg_size_fmt)  &(dbg_file_ent_id_fmt)  &(dbg_file_code_fmt) &(dbg_line_no_fmt)    &(user_ptr) &dbg_thread_name"
  )
)
else
(
  if ((v.value(&input_ptr)==v.value(&byte_static_heap_addr))||(v.value(&input_ptr)==v.value(&byte_dynamic_base_heap_addr))||(v.value(&input_ptr)==v.value(&byte_dynamic_app_heap_addr)))
  (
    &hdr_index=v.value(((byte_heap_hdr_struct*)&ptr)->block_num)
    &hdr_index_fmt=format.decimal(8,&hdr_index)
    &dbg_size=v.value(((byte_heap_hdr_struct*)&ptr)->size)
    &dbg_size_fmt=format.decimal(8,&dbg_size)
    &dbg_file_ent_id=&ENTITY_LAST
    &dbg_file_ent_id_fmt=format.decimal(8,&dbg_file_ent_id)
    &dbg_file_code_fmt=data.string(d:v.value(((byte_heap_hdr_struct*)&ptr)->file_name))
    &dbg_line_no=v.value(((byte_heap_hdr_struct*)&ptr)->line)
    &dbg_line_no_fmt=format.decimal(8,&dbg_line_no)

    print  "&curr_link_ptr &next_link_ptr_value &free_ptr_value (FREED) &(hdr_index_fmt) &(dbg_size_fmt)      -      &(dbg_file_code_fmt) &(dbg_line_no_fmt)    &(user_ptr)"
  )
  else
  (
    print  "&curr_link_ptr &next_link_ptr_value &free_ptr_value (FREED)"
  )
)

&next_link_ptr=v.value(&next_link_ptr_value)
if ((v.value(&next_link_ptr)>v.value(&curr_link_ptr))&&(v.value(&next_link_ptr)>=v.value(&tx_byte_pool_start))&&(v.value(&next_link_ptr)<v.value(&tx_byte_pool_end)))
(
  if (v.value(&next_link_ptr)!=v.value(&tx_byte_pool_end-8))
  (
    goto CMM_LOOP_BYTE_POOL
  )
  else
  (
    &curr_link_ptr=&next_link_ptr
    &next_link_ptr_value=v.value(*(unsigned int*)&next_link_ptr)
    print  "&curr_link_ptr &next_link_ptr_value COMPLETED"
    &curr_link_ptr=&tx_byte_pool_end
  )
)

if (v.value(&curr_link_ptr)<v.value(&tx_byte_pool_end))
(
  print "&curr_link_ptr -- &tx_byte_pool_end: left " format.decimal(0,v.value(&tx_byte_pool_end-&curr_link_ptr)) " bytes!!"
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  End                                                                                                   ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CMM_FILE_CLOSE:
print ""
area.close output_file_win
area.clear output_file_win

type "&output_file_path"

CMM_END:
area.select logging_win

print ""
print "End time : " clock.date() "  " clock.time() "  "

; Close the logging output window
; wait 1s
if (&err==0)
(
  area.close logging_win
  do "&curr_script_dir\_trace32_area_delete.cmm" "logging_win"
)

enddo

